/***
BSD 2-Clause License

Copyright (c) 2024, Hilda Romero-Velo
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**/

//
// Created by Hilda Romero-Velo on March 2024.
//
#include <string>
#include <iostream>
#include <vector>
#include "utils_time.hpp"
#include <fstream>
#include <cstdio>
#include <memory>
#include <cstring>
#include <cstdlib>

using namespace std;

// Cell structure definition.
struct Cell
{
    int score = 0;
    int text_origin_pos = 0;
    int query_origin_pos = 0;
};

// Load file and return content as string.
string load_file(const string &filename)
{
    ifstream file(filename);
    return file ? string((istreambuf_iterator<char>(file)), istreambuf_iterator<char>()) : "";
}

string launchFeaturesCommand(string command, string filename)
{
    // Execute command.
    int exitCode = system(command.c_str());
    if (exitCode != 0)
    {
        cerr << "Error executing command: " << strerror(errno) << endl;
        return "ERROR";
    }

    // Read output from the file generated by the command.
    string output = load_file(filename);

    return output;
}

string launchLocateCommand(string command)
{
    // Open a pipe to capture the output of the shell script.
    unique_ptr<FILE, decltype(&pclose)> pipe(popen(command.c_str(), "r"), pclose);
    if (!pipe)
    {
        cerr << "Error opening the pipe." << endl;
        return "ERROR";
    }

    // Read output from the pipe (only one line).
    char buffer[128];
    if (fgets(buffer, sizeof(buffer), pipe.get()) != nullptr)
    {
        string output(buffer);
        return output;
    }
    else
    {
        return "ERROR";
    }
}

// Function to perform an approximate alignment between the scores corpus and the provided query.
int approximate_alignment(string text, string query, int match_score, int mismatch_score)
{

    double time_sum = 0;

    int n = text.length();
    int m = query.length();

    vector<Cell> prev_column(m + 1);
    vector<Cell> current_column(m + 1);

    int max_score = 0;
    pair<int, int> max_position;
    pair<int, int> max_origin;

    // Compute distance matrix.
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= m; ++j)
        {
            int score = (text[i - 1] == query[j - 1]) ? match_score : mismatch_score;
            int max = 0;
            current_column[j].text_origin_pos = i;
            current_column[j].query_origin_pos = j;

            // Update initial values.
            if (i == 1)
            {
                prev_column[j].query_origin_pos = j;
                prev_column[j].score = -j;
            }
            if (j == 1)
            {
                current_column[0].text_origin_pos = i;
            }

            // Look for maximum value to update current cell.
            max = prev_column[j - 1].score + score - 1;

            if (prev_column[j - 1].score + score > max)
            {
                max = prev_column[j - 1].score + score;
                current_column[j].score = prev_column[j - 1].score + score;
                current_column[j].text_origin_pos = prev_column[j - 1].text_origin_pos;
                current_column[j].query_origin_pos = prev_column[j - 1].query_origin_pos;
            }
            if (current_column[j - 1].score + mismatch_score > max)
            {
                max = current_column[j - 1].score + mismatch_score;
                current_column[j].score = current_column[j - 1].score + mismatch_score;
                current_column[j].text_origin_pos = current_column[j - 1].text_origin_pos;
                current_column[j].query_origin_pos = current_column[j - 1].query_origin_pos;
            }
            if (prev_column[j].score + mismatch_score > max)
            {
                current_column[j].score = prev_column[j].score + mismatch_score;
                current_column[j].text_origin_pos = prev_column[j].text_origin_pos;
                current_column[j].query_origin_pos = prev_column[j].query_origin_pos;
            }

            // Update the maximum score and its position.
            if (current_column[j].score > max_score)
            {
                max_score = current_column[j].score;
                max_position = make_pair(i, j);
                max_origin = make_pair(current_column[j].text_origin_pos, current_column[j].query_origin_pos);
            }
        }

        // Update prev_column with current_column for next iteration.
        prev_column = current_column;
    }

    // .first is related to scores text and .second is related to query.
    return max_origin.first;
}

int main(int argc, char **argv)
{
    if (argc < 3)
    {
        cout << "Usage: " << argv[0] << " [-c|-d|-r] query_file" << endl;
        cout << "    This program computes an aprroximate alignment" << endl;
        cout << "    between a provided text file and a given query." << endl;
        cout << "    Arg 1: [-c|-d|-r]     Type of search: -c, chromatic; -d, diatonic; -r, rhythm." << endl;
        cout << "    Arg 2: query_file     Query file. WAV for chromatic and diatonic search. MIDI for rhythm search." << endl;
        return 1;
    }

    // Parse the command-line arguments.
    std::string search_feature = argv[1];
    std::string query_file = argv[2];

    // Check if the first argument is a valid search_feature.
    if (search_feature != "-c" && search_feature != "-d" && search_feature != "-r")
    {
        std::cerr << "Error: Invalid search feature. Types of search: -c, chromatic; -d, diatonic; -r, rhythm." << std::endl;
        return 1;
    }

    // Scores feature files.
    string chromatic_file = "scores_texts/chromatic_text.txt";
    string diatonic_file = "scores_texts/diatonic_text.txt";
    string rhythm_file = "scores_texts/rhythm_text.txt";

    // Query in single format files.
    string chromatic_query_file = "tmpq/chromatic_sf_query.txt";
    string diatonic_query_file = "tmpq/diatonic_sf_query.txt";
    string rhythm_query_file = "tmpq/rhythm_sf_query.txt";
    string query_sf_file = "";

    // Match and mismatch values configuration.
    int match_score = 1;
    int mismatch_score = -1;

    string text = "";
    string query = "";
    string flag = "";

    // Perform corresponding action based on the search_feature.
    if (search_feature == "-c")
    {
        text = load_file(chromatic_file);
        flag = "-c";
        query_sf_file = chromatic_query_file;
    }
    else if (search_feature == "-d")
    {
        text = load_file(diatonic_file);
        flag = "-d";
        query_sf_file = diatonic_query_file;
    }
    else if (search_feature == "-r")
    {
        text = load_file(rhythm_file);
        flag = "-r";
        query_sf_file = rhythm_query_file;
    }
    string featurescommand = "bash extractQueryFeatures.sh " + flag + " " + query_file;
    string cleancommand = "bash cleanFiles.sh";

    uint64_t t1 = util::time::user::now();
    query = launchFeaturesCommand(featurescommand, query_sf_file);
    uint64_t t2 = util::time::user::now();

    if (query == "ERROR")
    {
        system(cleancommand.c_str());
        return EXIT_FAILURE;
    }

    uint64_t alignTime1 = util::time::user::now();
    int pos_in_text = approximate_alignment(text, query, match_score, mismatch_score);
    uint64_t alignTime2 = util::time::user::now();

    string locatecommand = "python3 locateScore.py " + flag + " " + to_string(pos_in_text);

    uint64_t tLocate1 = util::time::user::now();
    string score = launchLocateCommand(locatecommand);
    uint64_t tLocate2 = util::time::user::now();

    auto time = util::time::duration_cast<util::time::milliseconds>(t2 - t1);
    auto alignTime = util::time::duration_cast<util::time::milliseconds>(alignTime2 - alignTime1);
    auto locateTime = util::time::duration_cast<util::time::milliseconds>(tLocate2 - tLocate1);

    if (score == "ERROR")
    {
        system(cleancommand.c_str());
        return EXIT_FAILURE;
    }
    else
    {
        cout << endl;
        cout << "------- *** -------" << endl;
        cout << endl;
        cout << "Score: " << score << endl;
        cout << "Process time: " << time << " milliseconds." << endl;
        cout << "Alignment time: " << alignTime << " milliseconds." << endl;
        cout << "Locate time: " << locateTime << " milliseconds." << endl;
        cout << endl;
        cout << "------- *** -------" << endl;
        cout << endl;
        system(cleancommand.c_str());
        return EXIT_SUCCESS;
    }
}